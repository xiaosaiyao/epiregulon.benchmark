---
title: "Comparison of different methods for calculationg weights in epiregulon with the use of the simulated data"
author: "Tomasz WÅ‚odarczyk"
date: "`r Sys.Date()`"
output:
  github_document:
    toc: true
    toc_depth: 2
---

```{r setup, include=TRUE}
knitr::opts_chunk$set(
	echo = TRUE,
	message = FALSE,
	warning = FALSE
)
```
# Introduction
This notebook compares across all options for weight computation which are available
in the epiregulon package. As a ground truth the data simulated by scMultiSim package is used. 

# Highlights

- GRN is composed of 5000 target genes and 500 transcription factors
- 9 cell clusters
- normalization of the count data
- using moving cutoffs in the workflows with regulon pruning

# GRN preparation

```{r child = "GRN_preparation.Rmd", cache = TRUE, cache.lazy = FALSE}
```

```{r child = "basic_simulation.Rmd"}
```

```{r eval = FALSE}
library(epiregulon.benchmark)
library(scMultiSim)
tfs <- NULL
counts_removal_old <- NULL
tfs <- unique(options_$GRN[,2])
# analysed using 900Gb of RAM
# set in .Renviron R_MAX_VSIZE = "800Gb"
counts_removal <- removeTF(sim_res, BPPARAM = BiocParallel::MulticoreParam(),
                                  batch_size = 20, sim_options = options_,
                           tfs = tfs)

true_ranks_matrix <- calculateTrueActivityRanks(basic_sim_res = sim_res,
                                                counts_removal = counts_removal,
                                                sim_options = options_)

transcription_difference_matrix <- calculateTrueActivityRanks(basic_sim_res = sim_res,
                                                    counts_removal = counts_removal,
                                                    sim_options = options_,
                                                    transcription_effect = TRUE)
```

```{r echo = FALSE}
#devtools::install("/gstore/project/epigen/epiregulon.benchmark", dependencies = FALSE)
#counts_removal <- readRDS("/gstore/scratch/u/wlodarct/counts_removal.rds")
true_ranks_matrix <- readRDS("/gstore/scratch/u/wlodarct/true_ranks_matrix.rds")
transcription_difference_matrix <- readRDS("/gstore/scratch/u/wlodarct/transcription_difference_matrix.rds")
```
# Distribution of the library sizes

```{r cache = TRUE, cache.lazy = FALSE}
hist(Matrix::colSums(sim_res$counts), main = "True counts", breaks = 30, xlab = "Total number of counts")
hist(Matrix::colSums(sim_res$counts_obs), main = "Observed counts", breaks = 30, xlab = "Total number of counts")
```

# Comparison of weight methods based on the true counts (normalized)

## Fixed cutoff

```{r cache = TRUE, cache.lazy = FALSE}
library(epiregulon)
library(epiregulon.benchmark)
#source("/gstore/project/epigen/epiregulon.benchmark/R/simulation.R")
input_objects <- processSimResults(sim_res)
clusters_list <- list("lmfit" = input_objects$geneExpMatrix$label,
                      "corr" = input_objects$geneExpMatrix$label,
                      "MI" = input_objects$geneExpMatrix$label)
# skip pruning since all connections are true
score_matrices  <- score_matrices_true_counts <-  getActivity(regulon = input_objects$regulon,
                              geneExpMatrix = input_objects$geneExpMatrix,
                              peakMatrix = input_objects$peakMatrix,
                              clusters_list = clusters_list,
                              exp_assay = "norm_counts",
                              peak_assay = "peak_obs")
```

```{r cache = TRUE, cache.lazy = FALSE}
library(scMultiSim)
library(epiregulon.benchmark)
df <- data.frame()
cat("Number of transcription factors retained:\n")
for(i in seq_along(score_matrices)){
    cat(sprintf("%15s: %d (%.2f%%)\n", names(score_matrices)[i], nrow(score_matrices[[i]]), nrow(score_matrices[[i]])*100/nrow(true_ranks_matrix)))
    method_res <- assessActivityAccuracy(activities_obs = score_matrices[[i]],
                                         true_ranks_matrix = true_ranks_matrix)

    df <- rbind(df, data.frame(tf = names(method_res$interchange_number), 
                               method = names(score_matrices)[i], 
                               interchanges = method_res$interchange_number))
}
boxplot(df$interchanges~df$method, xlab = "Weight method", ylab = "Rankings mismatch", main = "True normalized counts")
```

## Moving cutoff

```{r cache = TRUE, cache.lazy = FALSE}
score_matrices  <- score_matrices_true_counts <-  getActivity(regulon = input_objects$regulon,
                              geneExpMatrix = input_objects$geneExpMatrix,
                              peakMatrix = input_objects$peakMatrix,
                              clusters_list = clusters_list,
                              exp_assay = "norm_counts",
                              peak_assay = "peak_obs",
                              peak_cutoff = NULL,
                              exp_cutoff = NULL)
```

```{r cache = TRUE, cache.lazy = FALSE}
library(scMultiSim)
library(epiregulon.benchmark)
df <- data.frame()
cat("Number of transcription factors retained:\n")
for(i in seq_along(score_matrices)){
    cat(sprintf("%15s: %d (%.2f%%)\n", names(score_matrices)[i], nrow(score_matrices[[i]]), nrow(score_matrices[[i]])*100/nrow(true_ranks_matrix)))
    method_res <- assessActivityAccuracy(activities_obs = score_matrices[[i]],
                                         true_ranks_matrix = true_ranks_matrix)

    df <- rbind(df, data.frame(tf = names(method_res$interchange_number), 
                               method = names(score_matrices)[i], 
                               interchanges = method_res$interchange_number))
}
boxplot(df$interchanges~df$method, xlab = "Weight method", ylab = "Rankings mismatch", main = "True normalized counts")
```

# Comparison of weight methods based on the observed counts (normalized)

## Fixed cutoff

```{r cache = TRUE, cache.lazy = FALSE}
score_matrices <- getActivity(regulon = input_objects$regulon,
                              geneExpMatrix = input_objects$geneExpMatrix,
                              peakMatrix = input_objects$peakMatrix,
                              clusters_list = clusters_list,
                              exp_assay = "norm_counts_obs",
                              peak_assay = "peak_obs")

```

```{r cache = TRUE, cache.lazy = FALSE}
df <- data.frame()
cat("Number of transcription factors retained:\n")
for(i in seq_along(score_matrices)){
    cat(sprintf("%15s: %d (%.2f%%)\n", names(score_matrices)[i], nrow(score_matrices[[i]]), nrow(score_matrices[[i]])*100/nrow(true_ranks_matrix)))
    method_res <- assessActivityAccuracy(activities_obs = score_matrices[[i]],
                                         true_ranks_matrix = true_ranks_matrix)

    df <- rbind(df, data.frame(tf = names(method_res$interchange_number), method = names(score_matrices)[i], 
                               interchanges = method_res$interchange_number))
}
boxplot(df$interchanges~df$method, xlab = "Weight method", ylab = "Rankings mismatch",  main = "Normalized observed counts")
```

## Moving cutoff

```{r cache = TRUE, cache.lazy = FALSE}
score_matrices <- getActivity(regulon = input_objects$regulon,
                              geneExpMatrix = input_objects$geneExpMatrix,
                              peakMatrix = input_objects$peakMatrix,
                              clusters_list = clusters_list,
                              exp_assay = "norm_counts_obs",
                              peak_assay = "peak_obs",
                              peak_cutoff = NULL,
                              exp_cutoff = NULL)

```

```{r cache = TRUE, cache.lazy = FALSE}
df <- data.frame()
cat("Number of transcription factors retained:\n")
for(i in seq_along(score_matrices)){
    cat(sprintf("%15s: %d (%.2f%%)\n", names(score_matrices)[i], nrow(score_matrices[[i]]), nrow(score_matrices[[i]])*100/nrow(true_ranks_matrix)))
    method_res <- assessActivityAccuracy(activities_obs = score_matrices[[i]],
                                         true_ranks_matrix = true_ranks_matrix)

    df <- rbind(df, data.frame(tf = names(method_res$interchange_number), method = names(score_matrices)[i], 
                               interchanges = method_res$interchange_number))
}
boxplot(df$interchanges~df$method, xlab = "Weight method", ylab = "Rankings mismatch",  main = "Normalized observed counts")
```

# Comparison of weight methods based on the observed counts (normalized and log transformed)

## Fixed cutoff

```{r echo = FALSE, cache = TRUE, cache.lazy = FALSE}
score_matrices <-  getActivity(regulon = input_objects$regulon,
                              geneExpMatrix = input_objects$geneExpMatrix,
                              peakMatrix = input_objects$peakMatrix,
                              clusters_list = clusters_list,
                              exp_assay = "logcounts_obs",
                              peak_assay = "peak_obs")

```

```{r echo = FALSE, cache = TRUE, cache.lazy = FALSE}
df <- data.frame()
cat("Number of transcription factors retained:\n")
for(i in seq_along(score_matrices)){
    cat(sprintf("%15s: %d (%.2f%%)\n", names(score_matrices)[i], nrow(score_matrices[[i]]), nrow(score_matrices[[i]])*100/nrow(true_ranks_matrix)))
    method_res <- assessActivityAccuracy(activities_obs = score_matrices[[i]],
                                         true_ranks_matrix = true_ranks_matrix)

    df <- rbind(df, data.frame(tf = names(method_res$interchange_number), 
                               method = names(score_matrices)[i], 
                               interchanges = method_res$interchange_number))
}
boxplot(df$interchanges~df$method, xlab = "Weight method", ylab = "Rankings mismatch", main = "Rankings mismatch - log-transformed observed counts")
```

## Moving cutoff

```{r echo = FALSE, cache = TRUE, cache.lazy = FALSE}
score_matrices <-  getActivity(regulon = input_objects$regulon,
                              geneExpMatrix = input_objects$geneExpMatrix,
                              peakMatrix = input_objects$peakMatrix,
                              clusters_list = clusters_list,
                              exp_assay = "logcounts_obs",
                              peak_assay = "peak_obs",
                              peak_cutoff = NULL,
                              exp_cutoff = NULL)

```

```{r echo = FALSE, cache = TRUE, cache.lazy = FALSE}
df <- data.frame()
cat("Number of transcription factors retained:\n")
for(i in seq_along(score_matrices)){
    cat(sprintf("%15s: %d (%.2f%%)\n", names(score_matrices)[i], nrow(score_matrices[[i]]), nrow(score_matrices[[i]])*100/nrow(true_ranks_matrix)))
    method_res <- assessActivityAccuracy(activities_obs = score_matrices[[i]],
                                         true_ranks_matrix = true_ranks_matrix)

    df <- rbind(df, data.frame(tf = names(method_res$interchange_number), 
                               method = names(score_matrices)[i], 
                               interchanges = method_res$interchange_number))
}
boxplot(df$interchanges~df$method, xlab = "Weight method", ylab = "Rankings mismatch", main = "Rankings mismatch - log-transformed observed counts")
```

# Effect of the number of target genes

```{r cache = TRUE, cache.lazy = FALSE}
# calculate ranking mismatch score for true counts analysed using wilcoxon method in addWeights
ranking_accuracy_wilcoxon <- assessActivityAccuracy(activities_obs = score_matrices_true_counts$wilcoxon, true_ranks_matrix = true_ranks_matrix)

# determine number of target genes per tf
target_number <- split(options_$GRN,options_$GRN$regulator.gene) |> 
    lapply(nrow) |> 
    {function(x) unlist(x)}()
df <- data.frame(interchange_number = ranking_accuracy_wilcoxon$interchange_number, 
                 target_number = target_number[names(ranking_accuracy_wilcoxon$interchange_number)])

plot(df$interchange_number~df$target_number, main = "Effect of regulon size on the accuracy of prediction of\ntranscription factor activity", xlab = "Number of target genes per transcription factor", ylab = "Rankings mismatch score", pch = 16, cex = 0.5)
```

# Effect of the network pruning 

Now let's check the methods' performance by adding false connections and playing around with different cutoff values 
for the output from `pruneRegulon` function. By default we use moving cutoffs for binarization of 
peak and gene expression data. Moreover, only normalized true counts and true peak data are analysed.
We start from 50% of false connections in the regulon.

```{r cache = TRUE, cache.lazy = FALSE}
regulon.mixed <- addFalseConnections(input_objects$regulon) 
accuracyComparisonPruning(regulon.mixed, input_objects, true_ranks_matrix) |>
    ggplot(aes(x = method, y = interchanges, label = n_tf))+
    geom_boxplot()+
    stat_summary(fun = median, geom = "label")+
    facet_wrap(~pval_cutoff, ncol = 2)+
    xlab("Weights method")+
    ylab("Interchange number")+
    ggtitle("Rankings mismatch using different p-val cutoffs\n50% of false connections")+
    theme(plot.title = element.text(hjust = 0.5))
```
## Contaminating regulon with 65% of false connections

```{r cache = TRUE, cache.lazy = FALSE}
regulon.mixed <- addFalseConnections(input_objects$regulon, fraction_false = 0.65) 
accuracyComparisonPruning(regulon.mixed, input_objects, true_ranks_matrix) |>
    ggplot(aes(x = method, y = interchanges, label = n_tf))+
    geom_boxplot()+
    stat_summary(fun = median, geom = "label")+
    facet_wrap(~pval_cutoff, ncol = 2)+
    xlab("Weights method")+
    ylab("Interchange number")+
    ggtitle("Rankings mismatch using different p-val cutoffs\n65% of false connections")+
    theme(plot.title = element.text(hjust = 0.5))
```

## Contaminating regulon with 80% of false connections

```{r cache = TRUE, cache.lazy = FALSE}
regulon.mixed <- addFalseConnections(input_objects$regulon, fraction_false = 0.8) 
accuracyComparisonPruning(regulon.mixed, input_objects, true_ranks_matrix) |>
    ggplot(aes(x = method, y = interchanges, label = n_tf))+
    geom_boxplot()+
    stat_summary(fun = median, geom = "label")+
    facet_wrap(~pval_cutoff, ncol = 2)+
    xlab("Weights method")+
    ylab("Interchange number")+
    ggtitle("Rankings mismatch using different p-val cutoffs\n80% of false connections")+
    theme(plot.title = element.text(hjust = 0.5))
```

## Removing 50% of true connections and contaminating regulon with 80% of false connections
```{r cache = TRUE, cache.lazy = FALSE}
set.seed(1110)
# remove part of the true connections
keep_ind <- sample(1:nrow(input_objects$regulon), round(nrow(input_objects$regulon)/2))
regulon.mixed <- addFalseConnections(input_objects$regulon[keep_ind,], fraction_false = 0.8) 
accuracyComparisonPruning(regulon.mixed, input_objects, true_ranks_matrix) |>
    ggplot(aes(x = method, y = interchanges, label = n_tf))+
    geom_boxplot()+
    stat_summary(fun = median, geom = "label")+
    facet_wrap(~pval_cutoff, ncol = 2)+
    xlab("Weights method")+
    ylab("Interchange number")+
    ggtitle("Rankings mismatch using different p-val cutoffs\n80% of false connections and 50% of true ones")+
    theme(plot.title = element.text(hjust = 0.5))
```
